= lab.clj.protocols

Lab for experimenting with Clojure link:http://clojure.org/protocols[Protocols].

This project contains some minimal code intended to demonstrate some
basic uses of Clojure Protocols.

* <<start,getting started>>
* <<algebra,protocols as algebraic signatures>>
* <<deptypes,emulating dependent types>>

=== [[start]] getting started

1. Fork/clone
2. `lein repl`, then do `refresh-all` (see dev/user.clj for config stuff)

Then explore.  Several algebras are provided; using them as a pattern it
should be easy to implement your own.


* monoid N0:  (N, 0, +), underlying set is Natural numbers with zero, identity element is 0, operation is addition
* monoid N1:  (N, 1, *), underlying set is positive Natural numbers, identity element is 1, operation is multiplication
* Q3+:  quotient group mod 3 over integers, identity is 0, op is addition

[source,clojure]
----
user => (register-struct (algebra.struct.N0.))
user => (register-struct (algebra.struct.N1.))
user => (register-struct (algebra.struct.Q3+.))
user => (set-model :n0)
user => (** 3 5)           ;; we use ** as the abstract Group multiplication operator
8
user => (set-model :n1)
user => (** 3 5)
15
user => (set-model :quotient-3)
user => (** 3 5)
2
----

== [[algebra]] Protocols as Algebraic Operator Signatures

Algebra is where logic meets mathematics.  Loosely speaking, an
algebra is the marriage of a *signature* (which is a formal logical
calculus) and a *structure* (which is an informal mathematical
"object'); what ties them together is a *model*, which uses the
mathematical structure to interpret the linguistic expressions
formable using the signature.

What this implies is that many different structures may be used to
model a given signature or language.  The classic example, which is
implemented in this project, is the algebraic _*Group*_.  Groups are
extremely simple; they have an underlying set, one distinguished
element of that set that acts as an identity element, and one binary
operation; additionally, some basic rules about how the operation
works (e.g. a*b=b*a).  Infinitely many mathematical structures may
behave as Groups.  The textbook examples are: (N,0,\+), where the set
is Nat (with zero), the identity element is 0, and the operation is
addition, and (N+,1,*), where the set is the positive Natural numbers,
the identity element is 1, and the operation is multiplication.  The
structures are obviously not the same, but _as Groups_ they behave in
exactly the same way.

The relevance of such an algebraic perspective to programming is
pretty obvious, even though it is not often explicitly noted.  The
distinction between signature and structure is analogous to the one
between interface and implementation.  If you design well, you can
swap implementations of an interface without changing the behavior of
the system, e.g. going from a hashmap to an arraymap.

One of the beauties of Clojure's Protocols is that they make it
relatively easy to work in this manner.

Clojure's Protocols only include functions; algebras will always or at
least usually include some constant symbols (like the digits 0-9),
just as the underlying structures will contains some constant "values"
like the natural numbers.  So strictly speaking we should think of
Protocols as analogous to the "operator signature" of an algebra,
i.e. the subset of a signature consisting of all the function symbols.

Once you have a signature, (a Clojure Protocol definition), you need
to relate it to a structure in order to use it to express anything
meaningful.  Mathematically this involves specifying an
"interpretation", which is just a mapping from symbols in the
signature to values in the structure; I'm calling this a _model_.
Technically it's a little more complicated than that but the basic
concepts of _signature_, _structure_, and _model_ seem to be pretty
straightforward, and they match actual mathematical practice and
terminology pretty well.

So we think of a Clojure Protocol as a Signature (an "OpSig" or
operater signature, to be more precise), and we think of the code we
write to implement the operators in the signature as a structure.
To bind the two together, we use Clojure's `extend` macro, which does
precisely what we need: expresses a mapping from signature to
structure, or, in more programming-oriented language, from interface
to implementation.

However, to really make this work - to make it possible to switch from
one model to another (swap implementations) - you need more than just
`defprotocol` and friends.

=== the technique

The trick, which I learned from
link:https://github.com/mikera/core.matrix[core.matrix], is to exploit
the fact that Clojure's Protocol mechanism dispatches function calls
on the first arg.  Knowing this, we just parameterize operation calls
with a first arg whose sole purpose is to determine dispatch - the
"content" of the arg is irrelevant.  Of course to do this you have to
intercept the call in the first place, and then decide which type to
use for dispatch.  For that you keep a var; changing the var
effectively switches from one model (interpretation of the signature)
to another, by changing the dispatch parameter.

One reason I wrote this little app is to have a clean and simple
expression of the technique used by core.matrix.  I had to study that
code pretty hard before the technique stood out from implementation
details.  I don't mean the code is bad or hard to read, I mean it's
mixed up with the details of implementing core.matrix, so I wanted
something purely focussed on demonstrating the technique with minimal
extra stuff.  So that I'll be able to return to it in six months,
after I've forgotten everything about core.matrix, and so that others
can learn the technique independent of matrix stuff.  Also, I wanted
to highlight the algebraic structure of the technique, which I've
tried to do by using the algebraic terminology of signature,
structure, and model, and organizing the code accordingly.
 
The way I do it here is slightly different than the way core.matrix
does it.  I use a default implementation (defined on java.lang.Object)
to manage dispatch.  So calls to Protocol functions are always sent to
the default Object implementation, which checks to see what the
current model (implementation) is, and rewrites and forwards the call
as required.  core.matrix uses a separate API "wrapper" namespace to
do this, before calls reach the Protocol interface.  That approach has
the virtue of separating the user interface from the Protocol
interface, but that is also a vice, since it means you have to keep
them in sync.  I decided to use default Object as dispatcher in order
to ensure that the user API always matches the Protocol signature.
And also just to experiment.  I don't know which technique is
preferable.


== some algebras

=== link:https://en.wikipedia.org/wiki/Magma_(algebra)[magma]

"a set, M, equipped with a single binary operation, M × M → M. The binary operation must be closed by definition but no other properties are imposed."

"For all a, b in M, the result of the operation a • b is also in M." (link:https://en.wikipedia.org/wiki/Magma_(algebra)#Definition[magma])

Example:  Cayley table (link:http://math.stackexchange.com/questions/779507/can-you-give-me-some-concrete-examples-of-magmas[])

link:http://arxiv.org/ftp/math/papers/0304/0304490.pdf[]


=== link:https://en.wikipedia.org/wiki/Semigroup[semigroup]

set with associative binary combinator; an associative magma

link:https://en.wikipedia.org/wiki/Semigroup#Definition[definition]: "A semigroup is a set S together with a binary operation "\cdot" (that is, a function \cdot:S\times S\rightarrow S) that satisfies the associative property"

=== link:https://en.wikipedia.org/wiki/Monoid[monoid]

semigroup with identity

==== link:https://en.wikipedia.org/wiki/Free_monoid[free monoid]



=== link:https://en.wikipedia.org/wiki/Group_(mathematics)[group]

monoid with inverse

=== link:https://en.wikipedia.org/wiki/Symmetric_group[symmetric group]


=== link:https://en.wikipedia.org/wiki/Quotient_group[quotient group]

== [[deptypes]] Emulating Dependent Types

from map to foo-map

This is a map:  `{:a 1}`

This is a foo-map:  `{:foo 0, :a 1, :b 2}`

This is a foo-vector:  `[:foo 1 2 3]`

A foo-list:  `'(:foo 1 2 3)`

Clojure's link:http://clojure.org/protocols[Protocol] mechanism
(together with, say,
link:https://github.com/Prismatic/schema[Prismatic Schema] and/or
link:https://github.com/clojure/core.typed[core.typed]) allow us to
treat these as distinct types.  Since these types depend on a
particular data value - `:foo` - they thereby emulated dependent
types.

Another example: type VecInt4 - integer vectors of length 4.  We
start with a function `f` that operates on vectors:

[source,clojure]
----
(defn f [^PersistentVector v] ...do something with v...)
----

We want a function that only operates on integer vectors or length 4.
We can easily do this by writing `f` as a dispatch function that
inspects its argument at runtime and then forwards the call to an
appropriate implementation function.  If `f` receives an argument that
is not a vi4 datum, it will throw an exception; otherwise, it will
pass it to the implementation function, call it `vi4-f`.

A better way would be to use a multimethod.  The same thing happens,
but in this case Clojure's built-in dispatching mechanism for
multimethods will take responsibility for routing the call to the
appropriate implementation function.

But with Protocols we can define a function `vi4-f` that will only
ever be called on data of type VecInt4.

We will still have to inspect the arguments at runtime, but